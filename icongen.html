<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Image Processor (Full Size)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .preview-area {
            background-image: 
                linear-gradient(45deg, #eee 25%, transparent 25%), 
                linear-gradient(-45deg, #eee 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #eee 75%),
                linear-gradient(-45deg, transparent 75%, #eee 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        input[type="range"] { accent-color: #4ade80; }
        .custom-scrollbar::-webkit-scrollbar { width: 6px; height: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #1e293b; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #475569; border-radius: 10px; }
    </style>
</head>
<body class="bg-slate-900 min-h-screen flex items-center justify-center p-4 font-sans text-slate-200">
    <div class="max-w-6xl w-full bg-slate-800 rounded-3xl shadow-2xl p-6 border border-slate-700">
        <header class="mb-6 flex justify-between items-center border-b border-slate-700 pb-4">
            <div>
                <h1 class="text-xl font-bold text-white flex items-center gap-2">
                    HQ Background Remover <span class="text-[10px] bg-blue-500 text-white px-2 py-0.5 rounded-full uppercase">Full Size</span>
                </h1>
                <p class="text-slate-400 text-xs">元の解像度を維持して背景を透過します</p>
            </div>
            <div id="resolution-info" class="text-right text-xs font-mono text-slate-500">
                Resolution: -- x --
            </div>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-12 gap-6">
            <!-- Left: Controls (3 cols) -->
            <div class="lg:col-span-3 space-y-4">
                <div class="relative">
                    <label class="group block w-full border-2 border-dashed border-slate-600 rounded-xl p-4 text-center cursor-pointer hover:border-green-400 hover:bg-slate-700/50 transition-all">
                        <input type="file" id="upload" accept="image/*" class="hidden">
                        <div class="flex flex-col items-center">
                            <svg class="w-6 h-6 mb-1 text-slate-400 group-hover:text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"/></svg>
                            <span class="text-xs font-medium" id="filename-display">画像を選択</span>
                        </div>
                    </label>
                </div>

                <div class="bg-slate-700/30 p-4 rounded-xl space-y-4">
                    <div>
                        <div class="flex justify-between mb-1">
                            <label class="text-[10px] font-bold text-slate-400 uppercase tracking-widest">透過色</label>
                            <span id="colorHex" class="text-[10px] font-mono text-green-400">#000000</span>
                        </div>
                        <input type="color" id="targetColor" value="#000000" class="w-full h-10 rounded-lg border-none bg-slate-900 cursor-pointer p-1">
                    </div>

                    <div>
                        <div class="flex justify-between mb-1">
                            <label class="text-[10px] font-bold text-slate-400 uppercase tracking-widest">許容誤差</label>
                            <span id="fuzzDisplay" class="text-[10px] font-mono text-green-400">20</span>
                        </div>
                        <input type="range" id="threshold" min="0" max="150" value="20" class="w-full h-1.5 bg-slate-600 rounded-lg appearance-none cursor-pointer">
                    </div>
                    
                    <div>
                        <div class="flex justify-between mb-1">
                            <label class="text-[10px] font-bold text-slate-400 uppercase tracking-widest">スムージング</label>
                            <span id="smoothDisplay" class="text-[10px] font-mono text-green-400">10</span>
                        </div>
                        <input type="range" id="smoothing" min="1" max="100" value="10" class="w-full h-1.5 bg-slate-600 rounded-lg appearance-none cursor-pointer">
                    </div>
                </div>

                <button id="downloadBtn" disabled class="w-full bg-green-500 hover:bg-green-400 disabled:bg-slate-700 disabled:text-slate-500 text-slate-900 font-bold py-3 rounded-xl transition-all shadow-lg active:scale-95 flex justify-center items-center gap-2 text-sm">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/></svg>
                    等倍サイズで保存
                </button>
            </div>

            <!-- Right: Preview Area (9 cols) -->
            <div class="lg:col-span-9 grid grid-cols-1 gap-4">
                <div class="flex flex-col">
                    <span class="text-[10px] font-bold text-slate-500 uppercase tracking-widest mb-2">Editor Preview (Click image to pick color)</span>
                    <div class="relative bg-slate-900 rounded-2xl border border-slate-700 overflow-hidden aspect-video flex items-center justify-center">
                        <div class="absolute inset-0 overflow-auto custom-scrollbar p-4 flex items-center justify-center preview-area">
                            <canvas id="mainCanvas" class="max-w-none shadow-2xl cursor-crosshair"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const upload = document.getElementById('upload');
        const mainCanvas = document.getElementById('mainCanvas');
        const targetColor = document.getElementById('targetColor');
        const colorHex = document.getElementById('colorHex');
        const thresholdInput = document.getElementById('threshold');
        const smoothingInput = document.getElementById('smoothing');
        const downloadBtn = document.getElementById('downloadBtn');
        const filenameDisplay = document.getElementById('filename-display');
        const resInfo = document.getElementById('resolution-info');

        let originalImage = null;
        // 描画用のオフスクリーンキャンバス（元データを保持）
        const offscreenCanvas = document.createElement('canvas');
        const offscreenCtx = offscreenCanvas.getContext('2d', { willReadFrequently: true });

        upload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            filenameDisplay.textContent = file.name;

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;
                    resInfo.textContent = `Resolution: ${img.width} x ${img.height}`;
                    
                    // 等倍サイズをセット
                    offscreenCanvas.width = img.width;
                    offscreenCanvas.height = img.height;
                    mainCanvas.width = img.width;
                    mainCanvas.height = img.height;
                    
                    processImage();
                    downloadBtn.disabled = false;
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        // カラーピッカー機能
        mainCanvas.addEventListener('mousedown', (e) => {
            if (!originalImage) return;
            const rect = mainCanvas.getBoundingClientRect();
            // キャンバス内の実際のピクセル座標を計算
            const scaleX = mainCanvas.width / rect.width;
            const scaleY = mainCanvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            // 透過処理前のオリジナルから色を取得するためにoffscreenを使用
            offscreenCtx.drawImage(originalImage, 0, 0);
            const pixel = offscreenCtx.getImageData(x, y, 1, 1).data;
            const hex = "#" + ("000000" + ((pixel[0] << 16) | (pixel[1] << 8) | pixel[2]).toString(16)).slice(-6);
            
            targetColor.value = hex;
            colorHex.textContent = hex.toUpperCase();
            processImage();
        });

        [targetColor, thresholdInput, smoothingInput].forEach(el => {
            el.addEventListener('input', () => {
                if (el.id === 'targetColor') colorHex.textContent = el.value.toUpperCase();
                if (el.id === 'threshold') document.getElementById('fuzzDisplay').textContent = el.value;
                if (el.id === 'smoothing') document.getElementById('smoothDisplay').textContent = el.value;
                processImage();
            });
        });

        function processImage() {
            if (!originalImage) return;

            const w = originalImage.width;
            const h = originalImage.height;

            // オリジナル画像をオフスクリーンに描画
            offscreenCtx.clearRect(0, 0, w, h);
            offscreenCtx.drawImage(originalImage, 0, 0);

            const imageData = offscreenCtx.getImageData(0, 0, w, h);
            const data = imageData.data;
            const target = hexToRgb(targetColor.value);
            const fuzz = parseFloat(thresholdInput.value);
            const edgeSmooth = parseFloat(smoothingInput.value);

            // 高速なループ処理
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i], g = data[i+1], b = data[i+2];
                
                // ユークリッド距離で色の近さを判定
                const dist = Math.sqrt(
                    (r - target.r) ** 2 +
                    (g - target.g) ** 2 +
                    (b - target.b) ** 2
                );

                if (dist < fuzz) {
                    data[i+3] = 0; // 完全に透過
                } else if (dist < fuzz + edgeSmooth) {
                    // 境界線を滑らかに減衰
                    const alpha = ((dist - fuzz) / edgeSmooth) * 255;
                    if (alpha < data[i+3]) {
                        data[i+3] = alpha;
                    }
                }
            }

            // 結果をメイン表示用キャンバスに反映
            const mainCtx = mainCanvas.getContext('2d');
            mainCtx.clearRect(0, 0, w, h);
            mainCtx.putImageData(imageData, 0, 0);
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : {r:0, g:0, b:0};
        }

        downloadBtn.addEventListener('click', () => {
            const now = new Date();
            const ts = now.getFullYear().toString().slice(-2) +
                (now.getMonth() + 1).toString().padStart(2, '0') +
                now.getDate().toString().padStart(2, '0') +
                "_" +
                now.getHours().toString().padStart(2, '0') +
                now.getMinutes().toString().padStart(2, '0');
            
            const link = document.createElement('a');
            link.download = `transparent_${ts}.png`; // 等倍の場合は汎用的なPNG
            link.href = mainCanvas.toDataURL('image/png');
            link.click();
        });
    </script>
</body>
</html>